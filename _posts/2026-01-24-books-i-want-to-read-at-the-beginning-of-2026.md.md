---
layout: post
title:  "Books I Want to Read at the Beginning of 2026"
description: "A curated reading list for early 2026 focused on mastering the fundamentals of programming, systems, and AI. These books go beyond tutorials, offering deep insights into how Python, Linux, Docker, and large language models really work."
date:   2026-01-24 15:00:00 +0200
categories: notes
keywords: books,reading list,technology,programming,software,engineering,python,docker,linux,artificial intelligence
tags: miscellaneous
image: "assets/2026-01-24/cover.jpg" # Image for RSS
comments: true
---

![Federico Faruffini - La lettrice (1864-1865)]({{site.url}}/assets/2026-01-24/cover.jpg)

At the beginning of 2026, I want to slow down a bit and go deeper. Instead of skimming blog posts, docs, or hot takes, I’m deliberately choosing books that explain *how things work*, not just *how to use them*. This reading list reflects that mindset: fundamentals first, abstractions second.

<div class="book-block">
    <h2>"Learning Python: Powerful Object-Oriented Programming, 6th Edition" by Mark Lutz (2025)</h2>
    <p><img src="{{site.url}}/assets/2026-01-24/lutz.jpg" width="200" style="border-radius: 0; float: left; margin:10px 20px 0 0;" />Python is often treated as an “easy” language, which sometimes leads to shallow understanding and sloppy mental models. I want to revisit Python properly, with a focus on its object model, execution semantics, and idiomatic structure. This book has a reputation for being thorough rather than trendy, which makes it a good antidote to copy-paste programming and framework-driven thinking.
    </p>
    <p>Mark Lutz’s book is extremely comprehensive, covering everything from the basics to advanced topics. The chapters are detailed and dense, with numerous examples and exercises that encourage deep thinking rather than superficial reading. It’s structured in a way that allows readers to build a strong conceptual foundation before diving into practical coding, making it an enduring reference rather than a quick tutorial.</p>
</div>

<div class="book-block">
    <h2>"Docker: Up and Running" by Karl Matthias and Sean Kane (2023)</h2>
    <p><img src="{{site.url}}/assets/2026-01-24/docker.jpg" width="200" style="border-radius: 0; float: left; margin:10px 20px 0 0;" />Containers are everywhere, but they’re also frequently misunderstood. I’m reading this book to strengthen my mental model of Docker beyond `Dockerfile` recipes and CI snippets. I want to better understand what Docker actually abstracts, where the boundaries are, and how it fits into a broader system architecture rather than treating it as magic glue.</p>
    <p>The book provides a hands-on, practical approach to learning Docker, balancing theory with real-world examples. It covers the full lifecycle of containers, from image creation to deployment and orchestration, while explaining the reasoning behind Docker’s design decisions. Its examples are realistic, making it easier to connect concepts to everyday system administration and development tasks.</p>
</div>

<div class="book-block">
    <h2>"How Linux Works: What Every Superuser Should Know" by Brian Ward (2021)</h2>
    <p><img src="{{site.url}}/assets/2026-01-24/linux.jpg" width="200" style="border-radius: 0; float: left; margin:10px 20px 0 0;" />Linux is one of those systems you can use for years without really *understanding*. This book appeals to me because it focuses on internals: processes, memory, filesystems, booting, and networking. I’m less interested in memorizing commands and more interested in building intuition about the operating system as a living system that everything else depends on.</p>
    <p>Brian Ward’s writing is clear and approachable, with a focus on explaining the “why” behind Linux mechanisms rather than just the “how.” Each chapter builds understanding progressively, with diagrams and examples that clarify complex topics. It’s well-suited for developers, sysadmins, or anyone who wants to move from command-line user to someone who really grasps how Linux functions under the hood.</p>
</div>

<div class="book-block">
    <h2>"Build a Large Language Model (From Scratch)" by Sebastian Raschka (2024)</h2>
    <p><img src="{{site.url}}/assets/2026-01-24/raschka.jpg" width="200" style="border-radius: 0; float: left; margin:10px 20px 0 0;" />Large Language Models are often discussed at a very high level, which makes it easy to sound smart without actually understanding much. This book promises the opposite: starting from first principles and building a model step by step. I’m interested not just in *using* LLMs, but in understanding their limitations, trade-offs, and why they behave the way they do.</p>
    <p>Raschka’s book combines theory, mathematics, and practical implementation in a way that’s rare for LLM resources. Each chapter walks the reader through building components from scratch, providing Python code and explanations that illuminate underlying concepts. It’s designed to give readers a genuine grasp of neural architectures, training dynamics, and evaluation metrics, making it a valuable guide for anyone serious about understanding modern AI models.</p>
</div>

<div class="book-block">
    <h2>"Designing Data-Intensive Applications" by Martin Kleppmann (2017)</h2>
    <p><img src="{{site.url}}/assets/2026-01-24/kleppmann.jpg" width="200" style="border-radius: 0; float: left; margin:10px 20px 0 0;" />This is a book I’ve wanted to read properly for a long time. Modern applications often look simple on the surface while hiding enormous complexity underneath, and this book is about that hidden layer: data storage, consistency, replication, and fault tolerance. I want to better understand how real systems behave under load, failure, and scale—beyond buzzwords like “distributed” or “event-driven.”</p>
    <p>Kleppmann’s book is widely regarded as a modern classic in system design. It’s dense but exceptionally clear, combining theory with real production examples from databases, message queues, and distributed systems. Rather than prescribing a single “correct” architecture, it focuses on trade-offs and design decisions, which makes it especially valuable when reasoning about large, data-heavy systems.</p>
</div>

---

Taken together, these books feel like a reset: fewer shortcuts, more fundamentals. Python, Linux, Docker, data-intensive systems, and large language models live at very different layers, but they all reward the same mindset—curiosity, patience, and a willingness to look under the hood.

I don’t expect to rush through this list. The point isn’t speed, but depth: reading slowly, thinking carefully, and letting ideas settle. If 2026 has a theme for me, this might be it.
